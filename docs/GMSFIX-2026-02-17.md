# GMS-Fix Dokumentation — 2026-02-17

## Zusammenfassung

Session zur Wiederherstellung von Google Play Services, Basic Integrity und
Account-Login nach einem fehlgeschlagenen Switch-Flow. Insgesamt **7 Bugs**
identifiziert und gefixt, davon 3 im Code und 4 am Gerät.

---

## Bug 1: `restorecon` überschreibt korrekten SELinux-Kontext

**Datei:** `host/engine/shifter.py` — `_restore_account_dbs()`

**Symptom:** Nach Switch-Flow kein Basic Integrity, kein Play Store.

**Root Cause:**
```
chcon u:object_r:accounts_data_file:s0 /data/system_ce/0/accounts_ce.db*  → KORREKT
restorecon -Rv /data/system_ce/0/accounts_ce.db                          → ÜBERSCHREIBT mit system_data_file!
```
`restorecon` liest die `file_contexts` Policy, die `/data/system_ce/0/*` als
`system_data_file` mappt. Es gibt **keine** spezifische Regel für `accounts_ce.db`
in der Policy. Dadurch wird der korrekte `chcon`-Kontext überschrieben.

**Fix:** `restorecon`-Aufruf komplett entfernt. Nur `chcon` verwenden.

---

## Bug 2: `_find_latest_tar()` Duplikat — TikTok-Restore Crash

**Datei:** `host/engine/shifter.py`

**Symptom:**
```
TikTok-Restore fehlgeschlagen: AppShifter._find_latest_tar() takes 2 positional arguments but 3 were given
```

**Root Cause:** Zwei `_find_latest_tar()` Methoden in derselben Klasse:
- Zeile ~880: `def _find_latest_tar(self, directory, prefix)` — für TikTok
- Zeile ~2469: `def _find_latest_tar(self, directory)` — für GMS/Accounts

In Python überschreibt die zweite Definition die erste. TikTok-Restore ruft
`self._find_latest_tar(tiktok_dir, "tiktok_app_")` auf → Crash weil die
aktive Methode nur 1 Argument akzeptiert.

**Fix:** Duplikat entfernt, `prefix` als optionalen Parameter gemacht:
```python
def _find_latest_tar(self, directory: Path, prefix: str = "") -> Optional[Path]:
```

---

## Bug 3: FBE-Bootloop — `tar -xf` in verschlüsseltes Verzeichnis

**Datei:** `host/engine/shifter.py` — `_restore_account_dbs()`

**Symptom:** Gerät in Bootloop nach Switch-Flow.

**Root Cause (aus `dmesg`):**
```
avc: denied { write } for comm="system_server" name="accounts_ce.db"
  tcontext=u:object_r:unlabeled:s0           ← Kernel sieht UNLABELED
  trawcon="u:object_r:accounts_data_file:s0"  ← Xattr auf Disk ist korrekt
```

Wenn `tar -xf` eine Datei **direkt** in `/data/system_ce/0/` (FBE-verschlüsselt)
extrahiert, wird der Inode mit SELinux-Xattrs erstellt, die der Kernel zur
Laufzeit als `unlabeled` auflöst. Auch `chcon` hilft nicht — der Raw-Kontext
stimmt, aber der Kernel ignoriert ihn.

`system_server` darf keine `unlabeled` Dateien öffnen →
`AccountManagerService.validateAccounts()` crasht → **BOOTLOOP**.

**Fix:** Komplett neue `_restore_account_dbs()` v4.0 "FBE-Safe":
1. tar in `/data/local/tmp/` extrahieren (außerhalb FBE)
2. `cat source > dest` kopiert Inhalt → frischer Inode in FBE-Zone
3. `chown`, `chmod`, `chcon` setzen Permissions
4. **Bootloop-Schutz:** SQLite-Header-Validierung + SELinux-Verify.
   Bei Fehlschlag wird die Datei **gelöscht** statt Bootloop zu riskieren.
5. `sync` + Temp-Dir Cleanup

---

## Bug 4: `accounts_de.db` Stale-Einträge — Google Login unmöglich

**Symptom:**
```
AccountManagerService: insertAccountIntoDatabase: Account {...}, skipping the DB insert failed
Auth: [AddAccountHelper] Account not present in database. This shouldn't happen.
```

**Root Cause:** Bei der Bootloop-Reparatur wurde nur `accounts_ce.db` gelöscht.
`accounts_de.db` (Device Encrypted) enthielt noch Stale-Einträge von alten
Accounts. Beim Hinzufügen eines neuen Google-Accounts scheiterte
`AccountsDb.insertDeAccount()` → `INTERNAL_ERROR`.

**Fix:** BEIDE Datenbanken löschen:
```bash
rm -f /data/system_ce/0/accounts_ce.db*
rm -f /data/system_de/0/accounts_de.db*
sync && reboot
```
Android erstellt beide DBs frisch beim Boot.

**Lektion:** Account-Repair muss IMMER beide DBs (CE + DE) behandeln.

---

## Bug 5: GMS Process Frozen + Zombie — Integrity Check hängt ewig

**Symptom:** Integrity Check lädt unendlich, keine Verbindung zu Servern.

**Root Cause (aus `ps -A | grep gms`):**
```
u0_a149  24394  ... do_freezer_trap  0 S com.google.android.gms      ← EINGEFROREN!
u0_a149  13821  ...                  0 Z [id.gms.unstable]            ← ZOMBIE!
```

- `com.google.android.gms` war vom Android App-Freezer eingefroren
  (`do_freezer_trap`). Ein gefrorener Prozess kann keine Binder-Requests,
  Services oder DroidGuard-Initialisierung ausführen.
- `com.google.android.gms.unstable` (DroidGuard-Isolationsprozess) war ein
  Zombie (State `Z`). Zombies blockieren die Erstellung neuer Instanzen
  desselben Prozesses.

**Konsequenz:**
```
GmsClientSupervisor: Timeout waiting for ServiceConnection callback
  com.google.android.gms.droidguard.service.START

NetworkScheduler.TED: Dropping task [...] DroidGuardFastRefreshGmsTaskBoundService
  (retries=3, PENDING)
```
DroidGuard konnte nicht starten → keine Attestierung → Integrity Check hängt.

**Fix:** Reboot. Der Zombie wird nur durch Zygote aufgeräumt, und der
Freezer-State wird bei Reboot zurückgesetzt.

Nach Reboot: alle 3 GMS-Prozesse (persistent, main, unstable) laufen
normal in `do_epoll_wait`, DroidGuard initialisiert sich, `dg.db` wird erstellt.

---

## Bug 6: TikTok Deep-Clean zu aggressiv

**Datei:** `host/engine/shifter.py` — `_deep_clean_tiktok_storage()`

**Symptom:** TikTok-Login geht bei Restore verloren.

**Root Cause:** `dangerous_dirs` enthielt `files/mmkv` und `databases` —
beide Ordner wurden komplett gelöscht. TikTok speichert Session-Tokens in
MMKV-Core-Dateien und bestimmten SQLite-DBs.

**Fix:** Selektive Bereinigung statt radikaler Löschung:
- **MMKV:** Nur Tracking-Keys löschen (`DeviceID`, `tiktok_device_config`, etc.)
- **Databases:** Nur Tracking-DBs löschen (`tracker.db`, `webview.db`, `ad_*.db`)
- **Erhalten:** MMKV-Core, Session-DBs, `shared_prefs`

---

## Reparatur-Reihenfolge (falls erneut nötig)

Wenn Google-Verbindung / Basic Integrity nach einem Switch verloren geht:

```bash
# 1. Alle Google-Apps stoppen
adb shell su -c "am force-stop com.google.android.gms"
adb shell su -c "am force-stop com.google.android.gsf"
adb shell su -c "am force-stop com.android.vending"

# 2. GMS/GSF/Vending komplett clearen
adb shell su -c "pm clear com.google.android.gms"
adb shell su -c "pm clear com.google.android.gsf"
adb shell su -c "pm clear com.android.vending"

# 3. BEIDE Account-DBs löschen (CE + DE!)
adb shell su -c "rm -f /data/system_ce/0/accounts_ce.db*"
adb shell su -c "rm -f /data/system_de/0/accounts_de.db*"
adb shell su -c "sync"

# 4. Reboot (räumt Zombies + Freezer auf)
adb reboot

# 5. Nach Boot: Google Account neu einloggen
#    Einstellungen → Konten → Konto hinzufügen → Google

# 6. Play Store öffnen (triggert DroidGuard-Init)
#    5 Minuten warten, dann Integrity Check testen
```

---

## Diagnosebefehle

```bash
# GMS-Prozesse prüfen (Freezer/Zombie erkennen)
adb shell su -c "ps -A | grep gms"
# Normal: do_epoll_wait | Frozen: do_freezer_trap | Zombie: Z

# DroidGuard-Status
adb shell su -c "ls -la /data/data/com.google.android.gms/databases/dg.db"

# SELinux-Kontext der Account-DBs
adb shell su -c "ls -laZ /data/system_ce/0/accounts_ce.db*"
adb shell su -c "ls -laZ /data/system_de/0/accounts_de.db*"

# SELinux-Denials
adb shell su -c "dmesg | grep 'avc.*denied' | grep -iE 'account|gms'"

# GSF Check-in
adb shell su -c "cat /data/data/com.google.android.gsf/shared_prefs/CheckinService.xml"

# Google Account vorhanden?
adb shell su -c "dumpsys account | grep com.google"

# Auth-Fehler
adb shell su -c "logcat -d | grep -iE 'auth.*error|auth.*fail|insertAccount'"
```

---

## Betroffene Dateien (Code-Änderungen)

| Datei | Änderung |
|-------|----------|
| `host/engine/shifter.py` | `_restore_account_dbs()` v4.0 FBE-Safe |
| `host/engine/shifter.py` | `_find_latest_tar()` Duplikat entfernt |
| `host/engine/shifter.py` | `_deep_clean_tiktok_storage()` v5.1 selektiv |
